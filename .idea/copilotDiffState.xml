<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(ConsNot)&#10;&#10;set(CMAKE_CXX_STANDARD 11)&#10;&#10;set(OPENSSL_ROOT_DIR &quot;C:/msys64/mingw64&quot;)&#10;set(CURL_ROOT_DIR &quot;C:/msys64/mingw64&quot;)&#10;&#10;set(ZLIB_ROOT &quot;C:/msys64/mingw64&quot;)&#10;set(ZLIB_INCLUDE_DIR &quot;${ZLIB_ROOT}/include&quot;)&#10;set(ZLIB_LIBRARY &quot;${ZLIB_ROOT}/lib/libz.dll.a&quot;)&#10;&#10;find_package(OpenSSL REQUIRED)&#10;&#10;find_package(CURL REQUIRED)&#10;&#10;find_package(ZLIB REQUIRED)&#10;&#10;include_directories(&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/src&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/include&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/lib&#10;    ${CURL_INCLUDE_DIRS}&#10;    ${OPENSSL_INCLUDE_DIR}&#10;    ${ZLIB_INCLUDE_DIR}&#10;&#10;)&#10;&#10;add_executable(ConsNot&#10;    src/main.cpp&#10;    include/Config.h&#10;    lib/dotenv.h&#10;    src/Config.cpp&#10;    include/Models.h&#10;    include/Requests.h&#10;    src/Requests.cpp&#10;    lib/json.h&#10;    include/Utils.h&#10;    include/Database.h&#10;)&#10;&#10;target_link_libraries(ConsNot PRIVATE ${CURL_LIBRARIES} ${OPENSSL_LIBRARIES})&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.31)&#10;project(ConsNot)&#10;&#10;set(CMAKE_CXX_STANDARD 11)&#10;&#10;set(OPENSSL_ROOT_DIR &quot;C:/msys64/mingw64&quot;)&#10;set(CURL_ROOT_DIR &quot;C:/msys64/mingw64&quot;)&#10;&#10;set(ZLIB_ROOT &quot;C:/msys64/mingw64&quot;)&#10;set(ZLIB_INCLUDE_DIR &quot;${ZLIB_ROOT}/include&quot;)&#10;set(ZLIB_LIBRARY &quot;${ZLIB_ROOT}/lib/libz.dll.a&quot;)&#10;&#10;# Add fmt library source files from local copy&#10;set(FMT_SRC &#10;    ${CMAKE_CURRENT_SOURCE_DIR}/lib/fmt/format.cc&#10;)&#10;&#10;# Create fmt library&#10;add_library(fmt STATIC ${FMT_SRC})&#10;target_include_directories(fmt PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/lib)&#10;&#10;find_package(OpenSSL REQUIRED)&#10;find_package(CURL REQUIRED)&#10;find_package(ZLIB REQUIRED)&#10;&#10;include_directories(&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/src&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/include&#10;    ${CMAKE_CURRENT_SOURCE_DIR}/lib&#10;    ${CURL_INCLUDE_DIRS}&#10;    ${OPENSSL_INCLUDE_DIR}&#10;    ${ZLIB_INCLUDE_DIR}&#10;)&#10;&#10;add_executable(ConsNot&#10;    src/main.cpp&#10;    include/Config.h&#10;    lib/dotenv.h&#10;    src/Config.cpp&#10;    include/Models.h&#10;    include/Requests.h&#10;    src/Requests.cpp&#10;    lib/json.h&#10;    include/Utils.h&#10;    include/Database.h&#10;)&#10;&#10;target_link_libraries(ConsNot PRIVATE ${CURL_LIBRARIES} ${OPENSSL_LIBRARIES} fmt)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/Utils.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Utils.h" />
              <option name="originalContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;#include &lt;string&gt;&#10;&#10;class Utils {&#10;public:&#10;    static inline std::string cleanCpf(std::string cpf) {&#10;        cpf.        &#10;    }&#10;};&#10;&#10;#endif" />
              <option name="updatedContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;#include &lt;string&gt;&#10;#include &lt;algorithm&gt;&#10;&#10;class Utils {&#10;public:&#10;    static inline std::string cleanCpf(std::string cpf) {&#10;        // Remove dots and dashes from the CPF&#10;        cpf.erase(std::remove_if(cpf.begin(), cpf.end(), &#10;                  [](char c) { return c == '.' || c == '-'; }), &#10;                  cpf.end());&#10;        return cpf;&#10;    }&#10;};&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/fmt/format.cc">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/fmt/format.cc" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Requests.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Requests.cpp" />
              <option name="originalContent" value="#include &quot;../include/Requests.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../lib/fmt/format.h&quot;&#10;#include &quot;../lib/json.h&quot;&#10;#include &quot;../include/Utils.h&quot;&#10;&#10;size_t Requests::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    std::string* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;Models::AccessTokenResp* Requests::GetAccessToken(std::string access, std::string password) {&#10;    CURL* curl = curl_easy_init();&#10;    std::string respBody;&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return nullptr;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;ClientId&quot;, &quot;63ccaojkma1th1pucikhn1n19k&quot;},&#10;        {&quot;AuthFlow&quot;, &quot;USER_PASSWORD_AUTH&quot;},&#10;        {&quot;AuthParameters&quot;, {{&quot;USERNAME&quot;, access}, {&quot;PASSWORD&quot;, password}}}&#10;    };&#10;&#10;    std::string str_bod = req_body.dump();&#10;&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/x-amz-json-1.1&quot;);&#10;    headers = curl_slist_append(headers, &quot;X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth&quot;);&#10;&#10;    curl_easy_setopt(curl, CURLOPT_URL, &quot;https://cognito-idp.us-east-2.amazonaws.com&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;&#10;    Models::AccessTokenResp* result = nullptr;&#10;    if (curl_easy_perform(curl) == CURLE_OK) {&#10;        nlohmann::json resp_json = nlohmann::json::parse(respBody, nullptr, false);&#10;        if (!resp_json.is_discarded() &amp;&amp; resp_json.contains(&quot;AuthenticationResult&quot;)) {&#10;            result = new Models::AccessTokenResp();&#10;            result-&gt;AuthenticationResult.AccessToken = resp_json[&quot;AuthenticationResult&quot;][&quot;AccessToken&quot;].get&lt;std::string&gt;();&#10;        }&#10;    }&#10;&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    return result;&#10;}&#10;&#10;Models::ResponseContent *Requests::GetApiReturn(std::string token, std::string cpf) {&#10;    auto cleaned_cpf = Utils::cleanCpf(cpf);&#10;    CURL* curl = curl_easy_init();&#10;    std::string respBody;&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return nullptr;&#10;    }&#10;    nlohmann::json json_bod = {&#10;        {&quot;numCpf&quot;, cleaned_cpf},&#10;        {&quot;bancoDestinoNovo&quot;, &quot;9993-MB&quot;},&#10;        {&quot;autorizacao&quot;, true},&#10;        {&quot;saldoTotal&quot;, &quot;&quot;},&#10;        {&quot;salarioBruto&quot;, &quot;&quot;},&#10;        {&quot;mesesTrabalhados&quot;, &quot;&quot;},&#10;        {&quot;dtNascimentoAux&quot;, &quot;false&quot;},&#10;        {&quot;numTelefone&quot;, &quot;&quot;},&#10;        {&quot;numeroDeParcelas&quot;, &quot;10&quot;}&#10;    };&#10;&#10;    std::string str_bod = json_bod.dump();&#10;&#10;    struct curl_slist* headers = nullptr;&#10;    auto auth = fmt::format(&quot;acesstoken : {}&quot;, token);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    headers = curl_slist_append(headers, &quot;Content-Type : application/json&quot;);&#10;    Models::ResponseContent* result = nullptr;&#10;    if (curl_easy_perform(curl) == CURLE_OK) {&#10;        nlohmann::json resp_json = nlohmann::json::parse(respBody, nullptr, false);&#10;        if (!resp_json.is_discarded()) {&#10;            result = new Models::ResponseContent();&#10;            result-&gt;AccessToken = resp_json[&quot;AuthenticationResult&quot;][&quot;AccessToken&quot;].get&lt;std::string&gt;();&#10;        }&#10;    }&#10;&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    return result;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Requests.h&quot;&#10;#include &lt;iostream&gt;&#10;#include &lt;curl/curl.h&gt;&#10;#include &quot;../lib/fmt/format.h&quot;&#10;#include &quot;../lib/json.h&quot;&#10;#include &quot;../include/Utils.h&quot;&#10;&#10;size_t Requests::WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {&#10;    size_t totalSize = size * nmemb;&#10;    std::string* resp = static_cast&lt;std::string*&gt;(userp);&#10;    resp-&gt;append(static_cast&lt;char*&gt;(contents), totalSize);&#10;    return totalSize;&#10;}&#10;&#10;Models::AccessTokenResp* Requests::GetAccessToken(std::string access, std::string password) {&#10;    CURL* curl = curl_easy_init();&#10;    std::string respBody;&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return nullptr;&#10;    }&#10;    nlohmann::json req_body = {&#10;        {&quot;ClientId&quot;, &quot;63ccaojkma1th1pucikhn1n19k&quot;},&#10;        {&quot;AuthFlow&quot;, &quot;USER_PASSWORD_AUTH&quot;},&#10;        {&quot;AuthParameters&quot;, {{&quot;USERNAME&quot;, access}, {&quot;PASSWORD&quot;, password}}}&#10;    };&#10;&#10;    std::string str_bod = req_body.dump();&#10;&#10;    struct curl_slist* headers = nullptr;&#10;    headers = curl_slist_append(headers, &quot;Content-Type: application/x-amz-json-1.1&quot;);&#10;    headers = curl_slist_append(headers, &quot;X-Amz-Target: AWSCognitoIdentityProviderService.InitiateAuth&quot;);&#10;&#10;    curl_easy_setopt(curl, CURLOPT_URL, &quot;https://cognito-idp.us-east-2.amazonaws.com&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;&#10;    Models::AccessTokenResp* result = nullptr;&#10;    if (curl_easy_perform(curl) == CURLE_OK) {&#10;        nlohmann::json resp_json = nlohmann::json::parse(respBody, nullptr, false);&#10;        if (!resp_json.is_discarded() &amp;&amp; resp_json.contains(&quot;AuthenticationResult&quot;)) {&#10;            result = new Models::AccessTokenResp();&#10;            result-&gt;AuthenticationResult.AccessToken = resp_json[&quot;AuthenticationResult&quot;][&quot;AccessToken&quot;].get&lt;std::string&gt;();&#10;        }&#10;    }&#10;&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    return result;&#10;}&#10;&#10;Models::ResponseContent *Requests::GetApiReturn(std::string token, std::string cpf, std::string apikey) {&#10;    auto cleaned_cpf = Utils::cleanCpf(cpf);&#10;    CURL* curl = curl_easy_init();&#10;    std::string respBody;&#10;    if (!curl) {&#10;        std::clog &lt;&lt; &quot;ERROR: Failed to initialize CURL\n&quot;;&#10;        return nullptr;&#10;    }&#10;    nlohmann::json json_bod = {&#10;        {&quot;numCpf&quot;, cleaned_cpf},&#10;        {&quot;bancoDestinoNovo&quot;, &quot;9993-MB&quot;},&#10;        {&quot;autorizacao&quot;, true},&#10;        {&quot;saldoTotal&quot;, &quot;&quot;},&#10;        {&quot;salarioBruto&quot;, &quot;&quot;},&#10;        {&quot;mesesTrabalhados&quot;, &quot;&quot;},&#10;        {&quot;dtNascimentoAux&quot;, &quot;false&quot;},&#10;        {&quot;numTelefone&quot;, &quot;&quot;},&#10;        {&quot;numeroDeParcelas&quot;, &quot;10&quot;}&#10;    };&#10;&#10;    std::string str_bod = json_bod.dump();&#10;&#10;    struct curl_slist* headers = nullptr;&#10;    auto auth = fmt::format(&quot;acesstoken : {}&quot;, token);&#10;    headers = curl_slist_append(headers, auth.c_str());&#10;    headers = curl_slist_append(headers, &quot;Content-Type : application/json&quot;);&#10;    headers = curl_slist_append(headers, (&quot;apikey : &quot; + apikey).c_str());&#10;    &#10;    curl_easy_setopt(curl, CURLOPT_URL, &quot;YOUR_API_ENDPOINT_URL_HERE&quot;); // Add the actual API endpoint URL&#10;    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);&#10;    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);&#10;    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, str_bod.c_str());&#10;    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);&#10;    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBody);&#10;    &#10;    Models::ResponseContent* result = nullptr;&#10;    if (curl_easy_perform(curl) == CURLE_OK) {&#10;        nlohmann::json resp_json = nlohmann::json::parse(respBody, nullptr, false);&#10;        if (!resp_json.is_discarded()) {&#10;            result = new Models::ResponseContent();&#10;            &#10;            // Deserialize ResponseContent fields from JSON response&#10;            if (resp_json.contains(&quot;error&quot;)) {&#10;                result-&gt;error = new bool(resp_json[&quot;error&quot;].get&lt;bool&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;avisos&quot;)) {&#10;                result-&gt;avisos = new std::vector&lt;Models::Aviso&gt;();&#10;                for (const auto&amp; aviso_json : resp_json[&quot;avisos&quot;]) {&#10;                    Models::Aviso aviso;&#10;                    aviso.aviso = aviso_json[&quot;aviso&quot;].get&lt;std::string&gt;();&#10;                    result-&gt;avisos-&gt;push_back(aviso);&#10;                }&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;isInstability&quot;)) {&#10;                result-&gt;isInstability = new bool(resp_json[&quot;isInstability&quot;].get&lt;bool&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;nome&quot;)) {&#10;                result-&gt;nome = new std::string(resp_json[&quot;nome&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;cpf&quot;)) {&#10;                result-&gt;cpf = new std::string(resp_json[&quot;cpf&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;dataNascimento&quot;)) {&#10;                result-&gt;dataNascimento = new std::string(resp_json[&quot;dataNascimento&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;idadeAnos&quot;)) {&#10;                result-&gt;idadeAnos = new uint32_t(resp_json[&quot;idadeAnos&quot;].get&lt;uint32_t&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;idadeMeses&quot;)) {&#10;                result-&gt;idadeMeses = new uint32_t(resp_json[&quot;idadeMeses&quot;].get&lt;uint32_t&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;telefone&quot;)) {&#10;                result-&gt;telefone = new std::string(resp_json[&quot;telefone&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;abordarComo&quot;)) {&#10;                result-&gt;abordarComo = new std::string(resp_json[&quot;abordarComo&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;valorLiberado&quot;)) {&#10;                result-&gt;valorLiberado = new std::string(resp_json[&quot;valorLiberado&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;percentualComissao&quot;)) {&#10;                result-&gt;percentualComissao = new double(resp_json[&quot;percentualComissao&quot;].get&lt;double&gt;());&#10;            }&#10;            &#10;            if (resp_json.contains(&quot;displayCardCreation&quot;)) {&#10;                result-&gt;displayCardCreation = new std::string(resp_json[&quot;displayCardCreation&quot;].get&lt;std::string&gt;());&#10;            }&#10;            &#10;            // Handle simulacoes if present&#10;            if (resp_json.contains(&quot;simulacoes&quot;)) {&#10;                result-&gt;simulacoes = new Models::Simulacao();&#10;                const auto&amp; sim_json = resp_json[&quot;simulacoes&quot;];&#10;                &#10;                // Deserialize Simulacao fields&#10;                if (sim_json.contains(&quot;parcelaNova&quot;)) {&#10;                    result-&gt;simulacoes-&gt;parcelaNova = sim_json[&quot;parcelaNova&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;valorOperacao&quot;)) {&#10;                    result-&gt;simulacoes-&gt;valorOperacao = sim_json[&quot;valorOperacao&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;prazo&quot;)) {&#10;                    result-&gt;simulacoes-&gt;prazo = sim_json[&quot;prazo&quot;].get&lt;uint32_t&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;bancoEmprestimo&quot;)) {&#10;                    result-&gt;simulacoes-&gt;bancoEmprestimo = sim_json[&quot;bancoEmprestimo&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;taxa&quot;)) {&#10;                    result-&gt;simulacoes-&gt;taxa = sim_json[&quot;taxa&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;nomeTabela&quot;)) {&#10;                    result-&gt;simulacoes-&gt;nomeTabela = sim_json[&quot;nomeTabela&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;atualizar&quot;)) {&#10;                    result-&gt;simulacoes-&gt;atualizar = sim_json[&quot;atualizar&quot;].get&lt;bool&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;idOrgao&quot;)) {&#10;                    result-&gt;simulacoes-&gt;idOrgao = sim_json[&quot;idOrgao&quot;].get&lt;uint32_t&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;coeficiente&quot;)) {&#10;                    result-&gt;simulacoes-&gt;coeficiente = sim_json[&quot;coeficiente&quot;].get&lt;double&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;codigoInternoTabela&quot;)) {&#10;                    result-&gt;simulacoes-&gt;codigoInternoTabela = sim_json[&quot;codigoInternoTabela&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;percentualComissao&quot;)) {&#10;                    result-&gt;simulacoes-&gt;percentualComissao = sim_json[&quot;percentualComissao&quot;].get&lt;double&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;percentualProducao&quot;)) {&#10;                    result-&gt;simulacoes-&gt;percentualProducao = sim_json[&quot;percentualProducao&quot;].get&lt;double&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;ativa&quot;)) {&#10;                    result-&gt;simulacoes-&gt;ativa = sim_json[&quot;ativa&quot;].get&lt;bool&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;produto&quot;)) {&#10;                    result-&gt;simulacoes-&gt;produto = sim_json[&quot;produto&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;valorLiberado&quot;)) {&#10;                    result-&gt;simulacoes-&gt;valorLiberado = sim_json[&quot;valorLiberado&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;saldoTotal&quot;)) {&#10;                    result-&gt;simulacoes-&gt;saldoTotal = new std::string(sim_json[&quot;saldoTotal&quot;].get&lt;std::string&gt;());&#10;                }&#10;                if (sim_json.contains(&quot;salarioBruto&quot;)) {&#10;                    result-&gt;simulacoes-&gt;salarioBruto = sim_json[&quot;salarioBruto&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;reservaDeSaldo&quot;)) {&#10;                    result-&gt;simulacoes-&gt;reservaDeSaldo = sim_json[&quot;reservaDeSaldo&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;apelidoBancoEmprestimo&quot;)) {&#10;                    result-&gt;simulacoes-&gt;apelidoBancoEmprestimo = sim_json[&quot;apelidoBancoEmprestimo&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;jurosTotais&quot;)) {&#10;                    result-&gt;simulacoes-&gt;jurosTotais = sim_json[&quot;jurosTotais&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;jurosPorAno&quot;)) {&#10;                    result-&gt;simulacoes-&gt;jurosPorAno = sim_json[&quot;jurosPorAno&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;jurosPorMes&quot;)) {&#10;                    result-&gt;simulacoes-&gt;jurosPorMes = sim_json[&quot;jurosPorMes&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;jurosEmprestimoPessoalPorAno&quot;)) {&#10;                    result-&gt;simulacoes-&gt;jurosEmprestimoPessoalPorAno = sim_json[&quot;jurosEmprestimoPessoalPorAno&quot;].get&lt;std::string&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;simulacaoConfiavel&quot;)) {&#10;                    result-&gt;simulacoes-&gt;simulacaoConfiavel = sim_json[&quot;simulacaoConfiavel&quot;].get&lt;bool&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;simulacaoFactivel&quot;)) {&#10;                    result-&gt;simulacoes-&gt;simulacaoFactivel = sim_json[&quot;simulacaoFactivel&quot;].get&lt;bool&gt;();&#10;                }&#10;                if (sim_json.contains(&quot;dataExpiracao&quot;)) {&#10;                    result-&gt;simulacoes-&gt;dataExpiracao = sim_json[&quot;dataExpiracao&quot;].get&lt;std::string&gt;();&#10;                }&#10;                &#10;                // Parse periodos if present&#10;                if (sim_json.contains(&quot;periodos&quot;)) {&#10;                    const auto&amp; periodos_json = sim_json[&quot;periodos&quot;];&#10;                    for (const auto&amp; periodo_json : periodos_json) {&#10;                        Models::Periodo periodo;&#10;                        if (periodo_json.contains(&quot;DataRepasse&quot;)) {&#10;                            periodo.DataRepasse = periodo_json[&quot;DataRepasse&quot;].get&lt;std::string&gt;();&#10;                        }&#10;                        if (periodo_json.contains(&quot;RepasseMaximo&quot;)) {&#10;                            periodo.RepasseMaximo = periodo_json[&quot;RepasseMaximo&quot;].get&lt;std::string&gt;();&#10;                        }&#10;                        if (periodo_json.contains(&quot;ValorFinanciado&quot;)) {&#10;                            periodo.ValorFinanciado = periodo_json[&quot;ValorFinanciado&quot;].get&lt;std::string&gt;();&#10;                        }&#10;                        if (periodo_json.contains(&quot;PercentualRepassado&quot;)) {&#10;                            periodo.PercentualRepassado = new std::string(periodo_json[&quot;PercentualRepassado&quot;].get&lt;std::string&gt;());&#10;                        }&#10;                        if (periodo_json.contains(&quot;SaqueRestante&quot;)) {&#10;                            periodo.SaqueRestante = new std::string(periodo_json[&quot;SaqueRestante&quot;].get&lt;std::string&gt;());&#10;                        }&#10;                        result-&gt;simulacoes-&gt;periodos.push_back(periodo);&#10;                    }&#10;                }&#10;                &#10;                // Parse mensagemProposta if present&#10;                if (sim_json.contains(&quot;mensagemProposta&quot;)) {&#10;                    const auto&amp; msg_json = sim_json[&quot;mensagemProposta&quot;];&#10;                    if (msg_json.contains(&quot;nome&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.nome = msg_json[&quot;nome&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;primeiroNome&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.primeiroNome = msg_json[&quot;primeiroNome&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;cpf&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.cpf = msg_json[&quot;cpf&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;apelidoBancoEmprestimoPort&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.apelidoBancoEmprestimoPort = msg_json[&quot;apelidoBancoEmprestimoPort&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;valorLiberado&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.valorLiberado = msg_json[&quot;valorLiberado&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;taxaContrato&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.taxaContrato = msg_json[&quot;taxaContrato&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;reservaDeSaldo&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.reservaDeSaldo = msg_json[&quot;reservaDeSaldo&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;numeroPeriodos&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.numeroPeriodos = msg_json[&quot;numeroPeriodos&quot;].get&lt;uint32_t&gt;();&#10;                    }&#10;                    if (msg_json.contains(&quot;mensagemDocumentosNecessarios&quot;)) {&#10;                        result-&gt;simulacoes-&gt;mensagemProposta.mensagemDocumentosNecessarios = msg_json[&quot;mensagemDocumentosNecessarios&quot;].get&lt;std::string&gt;();&#10;                    }&#10;                    &#10;                    // Parse mensagemPeriodos if present&#10;                    if (msg_json.contains(&quot;mensagemPeriodos&quot;)) {&#10;                        const auto&amp; msg_periodos_json = msg_json[&quot;mensagemPeriodos&quot;];&#10;                        for (const auto&amp; msg_periodo_json : msg_periodos_json) {&#10;                            Models::Periodo msg_periodo;&#10;                            if (msg_periodo_json.contains(&quot;DataRepasse&quot;)) {&#10;                                msg_periodo.DataRepasse = msg_periodo_json[&quot;DataRepasse&quot;].get&lt;std::string&gt;();&#10;                            }&#10;                            if (msg_periodo_json.contains(&quot;RepasseMaximo&quot;)) {&#10;                                msg_periodo.RepasseMaximo = msg_periodo_json[&quot;RepasseMaximo&quot;].get&lt;std::string&gt;();&#10;                            }&#10;                            if (msg_periodo_json.contains(&quot;ValorFinanciado&quot;)) {&#10;                                msg_periodo.ValorFinanciado = msg_periodo_json[&quot;ValorFinanciado&quot;].get&lt;std::string&gt;();&#10;                            }&#10;                            if (msg_periodo_json.contains(&quot;PercentualRepassado&quot;)) {&#10;                                msg_periodo.PercentualRepassado = new std::string(msg_periodo_json[&quot;PercentualRepassado&quot;].get&lt;std::string&gt;());&#10;                            }&#10;                            if (msg_periodo_json.contains(&quot;SaqueRestante&quot;)) {&#10;                                msg_periodo.SaqueRestante = new std::string(msg_periodo_json[&quot;SaqueRestante&quot;].get&lt;std::string&gt;());&#10;                            }&#10;                            result-&gt;simulacoes-&gt;mensagemProposta.mensagemPeriodos.push_back(msg_periodo);&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                // Parse avisos, informacoes, and objecoes&#10;                if (sim_json.contains(&quot;avisos&quot;)) {&#10;                    const auto&amp; avisos_json = sim_json[&quot;avisos&quot;];&#10;                    for (const auto&amp; aviso : avisos_json) {&#10;                        result-&gt;simulacoes-&gt;avisos.push_back(aviso.get&lt;std::string&gt;());&#10;                    }&#10;                }&#10;                &#10;                if (sim_json.contains(&quot;informacoes&quot;)) {&#10;                    const auto&amp; info_json = sim_json[&quot;informacoes&quot;];&#10;                    for (const auto&amp; info : info_json) {&#10;                        result-&gt;simulacoes-&gt;informacoes.push_back(info.get&lt;std::string&gt;());&#10;                    }&#10;                }&#10;                &#10;                if (sim_json.contains(&quot;objecoes&quot;)) {&#10;                    const auto&amp; obj_json = sim_json[&quot;objecoes&quot;];&#10;                    for (const auto&amp; obj_item : obj_json) {&#10;                        Models::Objecao obj;&#10;                        if (obj_item.contains(&quot;objecao&quot;)) {&#10;                            obj.objecao = obj_item[&quot;objecao&quot;].get&lt;std::string&gt;();&#10;                        }&#10;                        if (obj_item.contains(&quot;resposta&quot;)) {&#10;                            obj.resposta = obj_item[&quot;resposta&quot;].get&lt;std::string&gt;();&#10;                        }&#10;                        if (obj_item.contains(&quot;respostaCopiavel&quot;)) {&#10;                            obj.respostaCopiavel = new std::string(obj_item[&quot;respostaCopiavel&quot;].get&lt;std::string&gt;());&#10;                        }&#10;                        result-&gt;simulacoes-&gt;objecoes.push_back(obj);&#10;                    }&#10;                }&#10;                &#10;                if (sim_json.contains(&quot;isInstability&quot;)) {&#10;                    result-&gt;simulacoes-&gt;isInstability = sim_json[&quot;isInstability&quot;].get&lt;bool&gt;();&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    curl_slist_free_all(headers);&#10;    curl_easy_cleanup(curl);&#10;    return result;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>